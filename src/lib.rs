use rand_core::{RngCore, SeedableRng, impls};

const N:usize = 624;
const MSK1:u32 = 0xdfffffef;
const MSK2:u32 = 0xddfecb7f;
const MSK3:u32 = 0xbffaffff;
const MSK4:u32 = 0xbffffff6;

#[derive(Debug,Clone,PartialEq,Eq)]
pub struct SFMT{
        state_vector: [u32;N],
        rand_index: usize,
        index32: u32
    }

impl SFMT{
    pub fn new(seed:u32)->Self{
        let mut sfmt = Self{state_vector:[0;N], rand_index: N, index32: 0};
        Self::init_gen_rand(&mut sfmt, seed);
        sfmt
    }

    fn init_gen_rand(sfmt: &mut SFMT, seed:u32){
        use std::num::Wrapping;
        sfmt.state_vector[0] = seed;
        for i in 1..N{
            sfmt.state_vector[i] =  (Wrapping(1812433253) * Wrapping(sfmt.state_vector[i - 1] ^ (sfmt.state_vector[i - 1] >> 30)) + Wrapping(i as u32)).0;
        }
        Self::period_certifiaction(sfmt);
    }

    fn period_certifiaction(sfmt: &mut SFMT){
        const PARITY:[u32;4] = [1, 0, 0, 0x13c9e684];

        let mut inner = 0;
        for i in 0..4 {
            inner ^= sfmt.state_vector[i] & PARITY[i];
        }
        for i in [16, 8, 4, 2, 1]{
            inner ^= inner >> i;
        } 

        // check OK
        if (inner & 1) == 1{
                return;
        }
        // check NG, and modification
        for i in 0..4{
            let mut work = 1;
            for _ in 0..32{
                if (work & PARITY[i]) != 0{
                    sfmt.state_vector[i] ^= work;
                    return;
                }
                work <<= 1;
            }
        }
    }

    fn generate_rand_all(&mut self){
        let p = &mut self.state_vector;

        let mut a = 0;
        let mut b = 488;
        let mut c = 616;
        let mut d = 620;
        while {
            p[a + 3] = p[a + 3] ^ (p[a + 3] << 8) ^ (p[a + 2] >> 24) ^ (p[c + 3] >> 8) ^ (((p[b + 3] >> 11) & MSK4) >> 0) ^ (p[d + 3] << 18);
            p[a + 2] = p[a + 2] ^ (p[a + 2] << 8) ^ (p[a + 1] >> 24) ^ (p[c + 3] << 24) ^ (p[c + 2] >> 8) ^ (((p[b + 2] >> 11) & MSK3) >> 0) ^ (p[d + 2] << 18);
            p[a + 1] = p[a + 1] ^ (p[a + 1] << 8) ^ (p[a + 0] >> 24) ^ (p[c + 2] << 24) ^ (p[c + 1] >> 8) ^ (((p[b + 1] >> 11) & MSK2) >> 0) ^ (p[d + 1] << 18);
            p[a + 0] = p[a + 0] ^ (p[a + 0] << 8) ^ (p[c + 1] << 24) ^ (p[c + 0] >> 8) ^ (((p[b + 0] >> 11) & MSK1) >> 0) ^ (p[d + 0] << 18);
            c = d;
            d = a;
            a += 4;
            b += 4;
            if b >= 624{
                b = 0;
            }
            a < 624
        } {}
    }

    pub fn get_index(self)->u32{
        self.index32 >> 1
    }
}

impl SeedableRng for SFMT{
    type Seed = [u8; 4];

    fn from_seed(seed: Self::Seed) -> Self {
        let [s0, s1, s2, s3] = seed;
        let u32seed = s0 as u32 | (s1 as u32) << 8 | (s2 as u32) << 16 | (s3 as u32) << 24;
        Self::new(u32seed)
    }
}

impl RngCore for SFMT{
    fn next_u32(&mut self) -> u32 {
        if self.rand_index>=N {
            self.generate_rand_all();
            self.rand_index = 0;
        }
        let r = self.state_vector[self.rand_index];
        self.rand_index += 1;
        self.index32 += 1;
        r
    }

    fn next_u64(&mut self) -> u64 {
        self.next_u32() as u64 | (self.next_u32() as u64) << 32
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        impls::fill_bytes_via_next(self, dest)
    }

    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
        Ok(self.fill_bytes(dest))
    }
}
mod tests {
    #[allow(unused_imports)]
    use super::*;

    #[test]
    fn test_seed_0x1(){
        let mut rng = SFMT::new(1);
        assert_eq!(rng.next_u64(),11082061050238007972);//const is generated by C# impl
        for _ in 0..100{
            rng.next_u64();
        }
        assert_eq!(rng.next_u64(),16525848006431369950);//const is generated by C# impl
        for _ in 0..1_000_000{
            rng.next_u64();
        }
        assert_eq!(rng.next_u64(),4443747126670914780);//const is generated by C# impl
    }
}
